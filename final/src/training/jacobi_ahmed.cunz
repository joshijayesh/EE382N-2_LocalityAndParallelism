#include <vector>
#include <iostream>
#include <fstream>

#include <cuda.h>
#include <cuda_runtime.h>
#include <driver_functions.h>

#include "commons.hpp"
#include "commons.cuh"

#include "training/routine.hpp"
#include "training/routine.cuh"
#include "training/kernels.cuh"

#define TOL 1.0*pow(10.0,-10.0)
#define NoOfThreads 512
#define NoofThreads_2 2*NoOfThreads




inline void init_params(float*& A_s,float*& p_s, float*& R, float*& R_t, uint32_t n){
    /* Assume A/P already on device
    CUDAERR_CHECK(
        cudaMalloc((void **) &A, sizeof(float) * n*n),
        "Unable to malloc d_data", ERR_CUDA_MALLOC);
    CUDAERR_CHECK(
        cudaMalloc((void **) &p, sizeof(float) * n*n);
        "Unable to malloc d_data", ERR_CUDA_MALLOC);
    */
    CUDAERR_CHECK(
        cudaMalloc((void **) &A_s, sizeof(float) * n*n),
        "Unable to malloc d_data", ERR_CUDA_MALLOC);
    CUDAERR_CHECK(
        cudaMalloc((void **) &p_s, sizeof(float) * n*n),
        "Unable to malloc d_data", ERR_CUDA_MALLOC);
    CUDAERR_CHECK(
        cudaMalloc((void **) &R, sizeof(float) * n*n),
        "Unable to malloc d_data", ERR_CUDA_MALLOC);
    CUDAERR_CHECK(
        cudaMalloc((void **) &R_t, sizeof(float) * n*n),
        "Unable to malloc d_data", ERR_CUDA_MALLOC);



    /*  Assume A/P already on device
    CUDAERR_CHECK(
        cudaMemcpy(A, A_h, size, cudaMemcpyHostToDevice);
        "Unable to copy matrices to device!", ERR_CUDA_MEMCPY);
    CUDAERR_CHECK(
        cudaMemcpy(p, p_h, size, cudaMemcpyHostToDevice);
        "Unable to copy matrices to device!", ERR_CUDA_MEMCPY);
    */
}

__global__ void SetupRotationMatrix(float *R, float *R_t, float * A, int k, int m, int n){
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int p,q;
    if (idx <m)
    {
        if(k<m)
        {
            q = m-k+idx;
            if(q<=2*m-2*k-1) p = 2*m - 2*k - q-1;
            else if(q<=2*m-k-2) p = 4*m-2*k - q -2;
            else p = n-1;
        }
        else
        {
            q = 4*m - n - k - 1 +idx;

            if(q<2*m-k) p = n-1;
            else if(q<=4*m-2*k-2) p = 4*m-2*k - q -2;
            else p = 6*m-2*k-3-q;

        }

     //   printf("idx = %d, p = %d, q = %d\n",idx,p,q);

    double t; // tan 
    double Adiff = A[n*q +q] - A[n*p +p];
    double temp = A[n*p +q]; // float temp = A[k,l];
    if(abs(temp) < abs(Adiff)*exp10f(-36))
        t = temp/Adiff;
    else {
        double phi = Adiff/(2.0*temp);
        t = 1.0/(abs(phi) + sqrt(phi*phi + 1.0));
        if(phi < 0.0) 
            t = -t;
    }
    double c = 1.0/sqrt(t*t + 1.0); // cos
    double s = t*c;                 // sin

    R[n*p+p] = c;
    R[n*q+q] = c;
    
    R[n*p+q] = (p<q)?s:-s;
    R[n*q+p] = (p<q)?-s:s;

    R_t[n*p+p] = c;
    R_t[n*q+q] = c;
    
    R_t[n*p+q] = (p<q)?-s:s;
    R_t[n*q+p] = (p<q)?s:-s;

    }
}



/* Assume p_h is already initialized as Identity matrix */
void JacobiPCA::find_eigenvectors() {
    float *A = d_data_cov;
    float *p = d_eigenvectors;
    uint32_t n = num_images;
    uint32_t m = (n+1)/2;
    // printf("%s,%f\n","Tol = ",TOL);
    printf("%s\n","jacobi device side start" );

    float *A_s,*p_s,*R,*R_t;
    init_params(A_s,p_s,R,R_t,n);
 

    dim3 blockDim(256);
    dim3 gridDim((m + blockDim.x - 1) / blockDim.x);


    dim3 m_block2D (((n + MATMUL_TILE_DIM - 1) / MATMUL_TILE_DIM), ((n + MATMUL_TILE_DIM - 1) / MATMUL_TILE_DIM));
    dim3 m_grid2D (MATMUL_BLOCK_DIM_X, MATMUL_BLOCK_DIM_Y);


    int iter_max = 10;
    //iter - sweep
    for(int iter = 0; iter < iter_max; iter++){


       for(int k = 1;k<= 2*m-1;k++)
    //    for(int k = 1;k<= 1;k++)

        {
            cudaMemset(R,0,sizeof(float) * n*n);
            cudaMemset(R_t,0,sizeof(float) * n*n);
            SetupRotationMatrix<<<gridDim,blockDim>>>(R,R_t,A,k,m,n);
            cudaDeviceSynchronize();

            
            matmul<<<m_block2D, m_grid2D>>> (n, n, n, R, A, A_s);
            cudaDeviceSynchronize();

            matmul<<<m_block2D, m_grid2D>>> (n, n, n, A_s, R_t, A);
            cudaDeviceSynchronize();

            matmul<<<m_block2D, m_grid2D>>> (n, n, n,  p,R_t, p_s);
            cudaDeviceSynchronize();
	    
           cudaMemcpy(p,p_s,sizeof(float) * n*n,cudaMemcpyDeviceToDevice);
	     //p = p_s;
           


        }

    }

    printf("%s\n","jacobi device side ends" );

    float *R_host;

    R_host = (float *) malloc(sizeof(float) * (n*n));

    CUDAERR_CHECK(
        cudaMemcpy(R_host,
                   R,
                   sizeof(float) * n*n,
                   cudaMemcpyDeviceToHost),
        "Unable to copy data from device!: A", ERR_CUDA_MEMCPY);

    std::ofstream file("dump_Rotation.txt");
    for(int i = 0; i < n; i += 1) {
        for(int j = 0; j < n; j += 1) {
            file << R_host[i * n + j] << " ";
        }
        file << std::endl;
    }
    free(R_host);

    /* This can be done for debug
    size_t size = sizeof(float)* n*n;
    CUDAERR_CHECK(
        cudaMemcpy(p_h,p,size,cudaMemcpyDeviceToHost);
        "Unable to copy matrices to host!", ERR_CUDA_MEMCPY);
    CUDAERR_CHECK(
        cudaMemcpy(A_h,A,size,cudaMemcpyDeviceToHost);
        "Unable to copy matrices to host!", ERR_CUDA_MEMCPY);

    for(int io =0; io<n*n;io++)
        printf("%f,",p_h[io]);

    printf("%s\n,","Eigen values are" );
    for(int io =0; io<n;io++)
        printf("%f,",A_h[io*n + io]);
    */

    // need to leave it on device, host doesn't consume it yet
    // cudaFree(A);
    // cudaFree(p);
    cudaFree(A_s);
    cudaFree(p_s);
    cudaFree(R);
    cudaFree(R_t);

}



